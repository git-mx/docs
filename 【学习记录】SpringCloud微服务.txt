001.在开发环境中，咱们可以同时开启多IDEA同时运行多个项目，只需要将每个应用的端口设置成不一样即可
002.在开发环境中，除了在IDEA和tomcat等容器中启动服务，我们还可以将服务打成war包，然后使用cmd来运行
    首先cd到项目的根目录，
	然后执行mvn clean package  直到看到BUILD SUCCESS 字样
	再执行java -jar /target/imooc-eureka-0.0.1-SNAPSHOT.jar
	这样就会以jar包的形式运行项目，然后在浏览器输入对应的地址就可以访问了。
003.在同一个IDEA和同一个项目中可以用相同的配置文件同时运行多个项目副本，具体做法如下
    #如何在同一个项目里启动ImoocEurekaApplication1和ImoocEurekaApplication2呢，首先是在右上角那点击Edit Configuration
	#然后在左上角点击copy configuration 然后命名，
	#然后选中某一个后制定运行端口，制定运行端口的方法是在右边Configuration-Environment-VM options
	#里面填上-Dserver.port=8761,另一个填写成-Dserver.port=8762,如果有多个以此类推
	#使两个server互相注册的办法是，先以defaultZone: http://localhost:8762/eureka/的配置运行ImoocEurekaApplication1
	#然后将defaultZone: http://localhost:8762/eureka/改成defaultZone: http://localhost:8762/eureka/
	#之后运行ImoocEurekaApplication2
004.在同一个IDEA里以不同的配置文件运行多个项目副本，具体做法如下
    #这里没有application.yml文件，但是有server1和server2两个文件，在右上角点击
	#Edit Configuraion 然后在左上角的Spring Boot开面选中一个，点后点击左上角的copy Configuration
	#然后分别明明为ApplicationStarter1和ApplicationStarter2
	#然后选中ApplicationStarter1，选择右边Configuration-Enviroment-Environment variables-点击右侧文件夹图标
	#然后在出来的窗体中点击右上角的+号,Name设置成spring.profiles.active,Value设置成application-server1.yml的后半段server1
	#然后以此配置ApplicationStarter1设置成server2,
	#注意观察server1和server2配置文件的区别
005.哪些服务不适合上微服务架构和康威定律
	A系统中包含很多强事务场景的
	B业务相对稳定，迭代周期长
	C访问压力不大，可用性要求不高
006.康威定律  它大致的意思就是公司任何一个系统的设计方案和结构都是与公司的沟通结构是一致的
	反应到咱们微服务架构上来说就是，如果要做一个庞大的系统，有几百人甚至上千人开发的项目
	那么你就必须要使用微服务架构了，拆分服务的同时把这几百上千人的开发团队才分成几十个小团队
	这样做的好处就是，小团队之间的沟通成本更小，效率更高，
	你想想成百上千人在一个团队里那沟通起来那沟通成本得多高啊。
007.微服务的特点
	一系列微小的服务共同组成
	单独部署，跑在自己的进程里
	每个服务为独立的业务开发
	分布式管理
008.系统的扩展性
	一个系统可以从三个维度来扩展
	A.X轴 水平复制，就是指通过复制服务的副本通过集群加上负载均衡器的方式
	B.Y轴 数据分区，例如一个数据量庞大的业务可能需要按省份来建立数据表
	C.Z轴 功能拆分，就是微服务的架构把一个庞大的功能拆分成许多个小功能
009.在微服务架构中的功能拆分理论
	A.贯彻单一职责，松耦合，高内聚（高内聚的意思就是某一个特定的功能一定是在某一个服务内，而不是分散在一个服务中）
	B.关注点分离，
	  B1.按职责分离关注点，所谓按职责分离就是按照业务来划分服务，即某一个服务只针对特定的功能，比如订单、商品
	  B2.按通用性 通用性的组件就是通用性的，与具体的业务无关的组件，比如消息服务、用户服务等
	  B3.按粒度的意思就是，看微服务架构对服务拆分的程度，这个是在微服务架构设计之初就要考虑和预见到的，比如咱们在
	     系统架构设计阶段就要考虑是否需要把订单服务拆分成订单服务和支付服务两个服务，因为在前期可能数据和业务量都
		 不大将订单和支付服务做成一个订单服务都可以满足要求，但是在后期随着业务量的增大可能必须要将这两个服务拆分开来
010.服务无状态化
	对于数据的存储，主要包含几类数据：
	会话数据等，主要保存在内存中
	结构化数据，主要是业务逻辑相关
	文件图片数据，比较大，往往通过CDN下发
	非结构化数据，例如文本、评论等
	现在假设有这样一种情况，起初服务量小，业务量也小，于是用单体架构的形式做一个系统，让业务逻辑代码MYSQL都在一台机器上。
	有一天访问量多起来了，业务逻辑进程支撑不了高并发，MYSQL也支撑不了超大的数据量，这时候就需要服务无状态话，所谓负状态化
	简单点说就是把具体的业务逻辑服务和数据服务（缓存数据服务如session,结构化业务数据如MYSQL，图片文件服务数据，非机构化数据）
	分开部署，这样业务逻辑服务和数据服务可以单独的横向扩展（集群的话可以增加服务节点）而互不影响，
	无结构化的几个要点
	A.对于保存在内存里的数据，例如Session，可以放在外部统一的缓存中；
	B.对于业务相关的数据，则应该保存在统一的数据库中，如果性能扛不住，可以进行读写分离或者分布式数据库；
	C.对于文件，照片之类的数据，应该存放在统一的对象存储里面，通过CDN进行预加载；
	D.对于非结构化数据，可以存在在统一的搜索引擎里面，例如ElasticSearch；
	遗留问题：ElasticSearch数据存储
011.幂等的接口设计
	但是还有一个遗留的问题，就是已经分发，正在处理，但是尚未存储的数据，肯定会在内存中有一些，在进程重启的时候，数据还是会丢一些的，
	那这部分数据怎么办呢？这部分就需要通过重试进行解决，当本次调用过程中失败之后，前序的进程会进行重试，例如Dubbo就有重试机制。
	既然重试，就需要接口是幂等的，也即同一次交易，调用两次转账1元，不能最终转走2元。
	遗留问题：接口幂等https://blog.csdn.net/linjingke32/article/details/82726216
	
	
012.浏览器安装JsonView插件，调用接口返回的JSON数据会自动格式化
013.定义好一个接口和其方法之后，再定义一个类来实现该接口，这时候可以在实现类里面使用alt+insert快捷键来实现接口的方法
014.在定义和实现好一个mapper或者service之后就可以使用右键菜单中的go to - Test 或者使用快捷键 ctrl + shift + t 创建单元测试类了
    另外我们是不能为ServiceImpl实现类创建单元测试的，要测试Service直接针对ServiceInterface创建单元测试类
015.遗留问题：pom的<scope>runtime</scope>
016.一个列表操作的好东西List.stream()  里面有许多许多实用的功能，例如
	productInfoList.stream().map(ProductInfo::getCategoryType).collect(Collectors.toList());
	能够返回一个List<Integer>的列表。
017.dto data transfer object  vo view object TODO注释的意思是还没有做的事情
018.pom的dependency里面的组件，如果springcloud 也集成了这个组件就不用写版本号，例如com.google.code.gson
019.遗留问题：RPC框架
020.遗留问题：Restful
021.RestTemplate、LoadBalancerClient、ServiceClient
022.服务端发现和客户端发现
	* 对于服务发现来说，有两种发现方式，一种是服务端发现，一种是客户端发现，服务端发现的意思就是：所有服务对于客户端来说是透明的，客户端完全
	* 不需要知道服务端有哪些服务，服务注册中心为所有的服务端都设置了一个代理，客户端就是通过这些代理来发现服务的
	* 客户端发现，就是客户端实现知道有哪些服务已经注册到了服务注册中心，然后在自己代码里选定好对应的服务进行调用
	* 典型的服务端发现是zookeeper注册中心，SpringCloud的Eureka属于客户端发现
	遗留问题：zookeeper，需要知道zookeeper的具体用法和原理，以及怎么和SpringCloud集成
023.



	
	
	
	

	
	
